# 神经网络学习 Neural Nerworks Learning

## 模型表示

![pic1](pic/pic1.png)

$$
a_{1}^{(2)} = g(\Theta_{10}^{(1)}x_{0} + \Theta_{11}^{(1)}x_{1}+ \Theta_{12}^{(1)}x_{2}+\Theta_{13}^{(1)}x_{3}) 
$$
$$
a_{2}^{(2)} = g(\Theta_{20}^{(1)}x_{0} + \Theta_{21}^{(1)}x_{1}+ \Theta_{22}^{(1)}x_{2}+\Theta_{23}^{(1)}x_{3}) 
$$
$$
a_{3}^{(2)} = g(\Theta_{30}^{(1)}x_{0} + \Theta_{31}^{(1)}x_{1}+ \Theta_{32}^{(1)}x_{2}+\Theta_{33}^{(1)}x_{3}) 
$$

$$
h_{\Theta}(x)= a_{1}^{(3)} = g(\Theta_{10}^{(2)}a_{0}^{(2)} + \Theta_{11}^{(2)}a_{1}^{(2)}+ \Theta_{12}^{(2)}a_{2}^{(2)}+\Theta_{13}^{(2)}a_{3}^{(2)}) 
$$

上面表达式中$a_{i}^{(j)}$代表第$j$的第$i$个激活单元，$\Theta(j)$代表第$j$层到第$j+1$层权重矩阵。

上述模型我们也可以使用向量来表示:

$$
x =\begin{bmatrix}
    x0 \\
    x1 \\
    x3\\
    x4
\end{bmatrix}
$$

$$
z^{(2)} = \begin{bmatrix}
    z_{1}^{(2)} \\
    z_{2}^{(2)} \\
    z_{3}^{(2)} \\
\end{bmatrix}
$$

$$
z^{(2)} = \Theta^{(1)}x
$$

$$
Add \quad a_{0}^{(2)} = 1
$$

$$
z^{(3)} = \Theta^{(2)}a^{(2)}
$$

$$
h_{\Theta}(x) = a^{(3)} = g(z^{(3)})
$$

$$
z_{1}^{(2)} = \Theta_{10}^{(1)}x_{0} + \Theta_{11}^{(1)}x_{1}+ \Theta_{12}^{(1)}x_{2}+\Theta_{13}^{(1)}x_{3}
$$

## 代价函数

$$
J(\Theta) = - \frac{1}{m} \sum_{i=1}^m \sum_{k=1}^K \left[y^{(i)}_k \log ((h_\Theta (x^{(i)}))_k) + (1 - y^{(i)}_k)\log (1 - (h_\Theta(x^{(i)}))_k)\right] + \frac{\lambda}{2m}\sum_{l=1}^{L-1} \sum_{i=1}^{s_l} \sum_{j=1}^{s_{l+1}} ( \Theta_{j,i}^{(l)})^2
$$

>这个看起来复杂很多的代价函数背后的思想还是一样的，我们希望通过代价函数来观察算法预测的结果与真实情况的误差有多大，唯一不同的是，对于每一行特征，我们都会给出个预测，基本上我们可以利用循环，对每一行特征都预测个不同结果，然后在利用循环在个预测中选择可能性最高的一个，将其与中的实际数据进行比较。

>正则化的那一项只是排除了每一层后，每一层的 矩阵的和。最里层的循环循环所有的行（由 +1 层的激活单元数决定），循环则循环所有的列，由该层（层）的激活单元数所决定。即：与真实值之间的距离为每个样本-每个类输出的加和，对参数进行regularization的bias项处理所有参数的平方和。

## 反向传播算法 Backpropagation Algorithm

反向传播算法是用来计算$\frac{\partial}{\partial\Theta_{ij}^{(l)}}J_{(\Theta)}$的，它的计算规则为, 以四层神经网络为例:

![pic1](pic/4Nerve.png)

>其中 $K = 4$,$S_{L}=4$, $L=4$

使用$\delta$来表示误差，则:$\delta^(4) = a^{(4)}-y$ ：


$$
\delta^{(l)} =\begin{cases}
    a^{(l)} - y  & l = L \\
    (\Theta^{(l)}\delta^{(l+1)})^T .*g'(z^{(l)}) &  {l=2,3,...,L-1}
\end{cases}
$$

$$
g'(z^{(l)}) = a^{(l)} .* (1-a^{(l)})
$$

最终:

$$
 \frac{\partial}{\partial\Theta_{ij}^{(l)}}J_{(\Theta)}= a_j^{(l)}\delta_i^{(l+1)}
$$

$l$代表目前所计算的是第几层。

$j$代表目前计算层中的激活单元的下标，也将是下一层的第个输入变量的下标。

$i$代表下一层中误差单元的下标，是受到权重矩阵中第行影响的下一层中的误差单元的下标。

- 反向传播算法的具体步骤

>使用$\Delta_{ij}^{(l)}$来表示误差矩阵, 它的含义是**第$l$层的第$i$个激活单元受到第$j$个参数影响而导致的误差**

假定有训练集$(x^{(1)}, y^{(1)}),...,(x^{(m)},y^{(m)})$，使用了反向传播的神经网络训练过程如下：

1. $for \quad all \quad l,i,j$, 初始化权值梯度$\Delta^{(l)}$ :

$$
\Delta^{(l)} = 0
$$

2. $for \quad i=1  \quad to  \quad m$:
   
$$
\begin{aligned}
    & 令 a^{(1)} = x^{i} \\
    & 执行前向传播算法，计算各层的激活向量：a^{(l)} \\
    & 通过标签向量 y^{(i)}，计算输出层的误差向量：\delta^{(L)} = a^{(L)} - y^{(i)} \\
    & 反向依次计算其他层误差向量：\delta^{(L-1)},\delta^{(L-2)},...,\delta^{(2)} \\
    &求 \Delta_{ij}^{(l)} = a_j^{(l)}\delta_i^{(l+1)}，即：\Delta^{(l)} = \delta^{(l+1)}(a^{(l)})^T\\
\end{aligned}
$$

3. 求各层权值的更新增量$D^{(l)}$，连接偏置的权值不进行正规化：

$$
D^{(l)}_{i,j} =
\begin{cases}
\dfrac{1}{m}(\Delta^{(l)}_{i,j} + \lambda\Theta^{(l)}_{i,j}), \quad {if j \neq 0} \\
\frac{1}{m}\Delta_{ij}^{(l)}, \quad {if \quad j=0}
\end{cases}
$$

4. 更新各层的权值矩阵$\Theta(l)$ ，其中$\alpha$为学习率：

$$
\Theta^{(l)} = \Theta^{(l)} + \alpha D^{(l)}
$$

## 神经网络算法的一般步骤

网络结构：第一件要做的事是选择网络结构，即决定选择多少层以及决定每层分别有多少个单元。

第一层的单元数即我们训练集的特征数量。

最后一层的单元数是我们训练集的结果的类的数量。

如果隐藏层数大于1，确保每个隐藏层的单元个数相同，通常情况下隐藏层单元的个数越多越好。

我们真正要决定的是隐藏层的层数和每个中间层的单元数。

训练神经网络：

1. 参数的随机初始化
2. 利用正向传播方法计算所有的
3. 编写计算代价函数  的代码
4. 利用反向传播方法计算所有偏导数
5. 利用数值检验方法检验这些偏导数
6. 使用优化算法来最小化代价函数